
# IIC2562 - Taller de Programacion II
## 2018-2
Bienvenidos a la página de apoyo del curso Taller de Programacion II.

## Instrucciones del Curso
### Cómo se calcula la nota:
Este curso es 100% práctico. La nota final dependerá de la resolución por parte del alumno de problemas de [programación competitiva](https://es.wikipedia.org/wiki/Usuario:Ltaravilse/Programaci%C3%B3n_competitiva). Cada cierto tiempo (una vez cada 1 o 2 semanas) se publicará un *contest* (competencia, en español). Los contests se caracterizan por lo siguiente:

* Se publicarán en [codepit.io](https://www.codepit.io/), un sitio web brasileño (sí, casi todo está en portugués) que permite crear competencias utilizando problemas obtenidos de diferentes jueces online, con un scoreboard que se actualiza en tiempo real a medida que los participantes resuelven problemas. Para competir sólo basta con crearse una cuenta en [codepet.io](https://www.codepit.io/) y posteriormente unirse a los contests a medida que estos vayan siendo publicados.
* Las competencias pueden ser ya sea **individuales** o **grupales**.
* En el caso de competencias grupales, les está permitido armar grupos de un máximo de 3 alumn@s (codepit.io permite hacer esto fácilmente).
* Cada contest tiene su propia **exigencia _default_**, es decir, un número **mínimo** de problemas a resolver (el cual puede ser diferente para cada contest). Sin embargo, si el alumno **asiste a clases**, se le restará 1 problema a su exigencia en el contest correspondiente, obteniéndose así una **exigencia personalizada**. Por ejemplo, si un contest tiene una duración de 3 semanas con una exigencia default de X problemas, y supongamos que 2 clases están asociadas a dicho contest, si un alumno asiste a ambas clases entonces obtendrá una exigencia personalizada de (X-2), mientra que si sólo asiste a una clase será de (X-1), y si no asiste a ninguna tendrá una exigencia de X.
* Cada contest tendrá una duración oficial máxima (generalmente 2 o 3 semanas). El alumno (o grupo de alumnos) tendrá dicho plazo para resolver los problemas del contest. Sean N los problemas resueltos por el alumno (o grupo de alumnos) y Xp la exigencia personalizada de un alumno "p". Según la cantidad de problemas resueltos, se generan dos posibles sub-casos:
  * Si N >= Xp, dicho alumno obtiene una asistencia de 100% en dicho contest. Además, todos los problemas adicionales resueltos (N - Xp) se sumarán a un contador llamado **excedente total**, el cual se traducirá en un bonus en su nota final.
  * Si N < Xp, dicho alumno obtiene una asistencia de 100 * (Xp / N) % en dicho contest. Además, todos los problemas que le faltaron (Xp - N) se sumarán a un contador llamado **deuda total**. Esta deuda se puede reducir a través de 2 formas: agregando problemas a su contador de **excedente total** (punto anterior) o bien agregando problemas a su contador de **total upsolving** (punto siguiente).
* En codepit.io, cuando el plazo de un contest se acaba, los participantes pueden seguir enviando soluciones en un modo post-competencia conocido como **upsolving**. Todos los problemas resueltos en modo upsolving se agregarán a un contador llamado **total upsolving**, el cual se traducirá en un bonus en su nota final.


## Material de Apoyo

### General
* Canales de Youtube con muchas explicaciones:
  * Algorithms Live!: https://www.youtube.com/channel/UCBLr7ISa_YDy5qeATupf26w/
  * Tushar Roy - Coding Made Simple: https://www.youtube.com/channel/UCZLJf_R2sWyUtXSKiKlyvAw
  * Programación Competitiva CL:  https://www.youtube.com/channel/UCmVg7YyMS8H-65WCmkVHB9g/feed
* Repositorios con muchos códigos de ejemplo (implementaciones de algoritmos y estructuras de datos típicos):
  * Google Doc con muchos códigos (C++): https://docs.google.com/document/d/1rcex_saP4tExbbU62qGUjR3eenxOh-50i9Y45WtHkc4/edit
  * Google Doc con Apuntes de Robinson Castro et al (C++): https://docs.google.com/document/d/1pan53PU9_PIrPPVyNrbfXIAU-B6YnIaSBcB9lP9j0jE/edit
  * Repo de Apuntes de Pablo Messina (C++): https://github.com/PabloMessina/Competitive-Programming-Material
  * Repo de Apuntes del team Caloventor en Dos (C++): https://github.com/mvpossum/eldiego
* Otras páginas con links a muchos recursos y material de estudio:
  * GeeksForGeeks: HOW TO PREPARE FOR ACM ICPC: https://www.geeksforgeeks.org/how-to-prepare-for-acm-icpc/
  * Techie Delight: Coding made easy: http://www.techiedelight.com/
  * Sitio web del Taller de la U. de Chile: http://progcomp.cl/taller
  * Material Campamento 2015 progcomp.cl: http://campamento2015.progcomp.cl/material
  * Material Campamento 2016 progcomp.cl: http://campamento2016.progcomp.cl/material
  * Material Campamento 2017 progcomp.cl: http://campamento2017.progcomp.cl/material
* Libros con harto material de programación competitiva:
  * Competitive Programmer's Handbook: https://www.cses.fi/book.pdf
  * Competitive Programming 2: https://www.scribd.com/doc/155208844/Competitive-Programming-2

### Soluciones Regionales Latinoamericanas
* Blogs con explicaciones:
  * Blog CaloventorEnDos: http://caloventorendos.blogspot.cl
  * Chocoblog: https://chococontest.wordpress.com/
* Google Sheet con soluciones de las últimas regionales (work in progress): https://docs.google.com/spreadsheets/d/1F8aBV83xKPVFfq_A0EKhCa8qbjf0gKKg8puQF-rbonQ/
* Inputs y outputs oficiales de regionales latam pasadas: http://maratona.ime.usp.br/antigas18.html

### Para aprender C++ (MUY RECOMENDADO)
 * ¿Qué es mejor para leer input / imprimir output? cin/cout vs printf/scanf: http://www.cplusplus.com/forum/beginner/34165/
 * LearnCpp: http://www.learncpp.com/
 * Intro a C++: https://youtu.be/pqWsOsfGKA0
 * Intro a la Programación Competitiva en C++: https://youtu.be/zTUJFG34Tyw
 * Estructuras básicas en C++: https://youtu.be/OldL5e5eGmY
 * C++ Programming Video Tutorials For Beginners [ Complete Series ]: https://www.youtube.com/playlist?list=PLfVsf4Bjg79Cu5MYkyJ-u4SyQmMhFeC1C
 * C++ Tutorial (SOLO LEARN: EVERYONE CAN CODE): https://www.sololearn.com/Course/CPlusPlus/
 * C++ Cheat Sheet de Pablo Messina: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/c%2B%2B_cheat_sheet.cpp 
 * Instalando y corriendo C++:
   * Windows:
     * http://www.mingw.org/Welcome_to_MinGW_org
     * https://www.quora.com/How-do-I-compile-a-C++-program-on-a-Windows-PC-in-CMD
   * Ubuntu:
     * http://askubuntu.com/questions/348654/how-to-install-g-compiler
     * http://askubuntu.com/questions/61408/what-is-a-command-to-compile-and-run-c-programs
   * Mac:
     * https://www.quora.com/What-is-the-best-FREE-C-C++-compiler-for-Mac-OS
     * http://stackoverflow.com/questions/9148488/how-do-i-compile-c-with-clang

### Search:
* Binary Search:
  * https://www.youtube.com/watch?v=jf1baieXkSQ
  * https://www.tutorialspoint.com/data_structures_algorithms/binary_search_algorithm.htm
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Search/BinarySearch.cpp
  * http://progcomp.cl/binarysearch
* Ternary Search:
  * https://en.wikipedia.org/wiki/Ternary_search
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Search/TernarySearch.cpp

### Data Structures:
* Union Find (Disjoint Sets):
  * https://www.youtube.com/watch?v=ID00PMy0-vE
  * http://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Data_Structures/unionfind.cpp
* Segment Tree:
  * http://progcomp.cl/segmenttree
  * https://www.youtube.com/watch?v=ZBHKZF5w4YU
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Data_Structures/segment-tree.cpp
* Segment Tree Lazy: https://www.youtube.com/watch?v=xuoQdt5pHj0
* Fenwick Tree (a.k.a. BIT o Binary Indexed Tree):  
  * (recomendado) (explicación de Jorge Pérez) https://youtu.be/0PzR0IoqkkU?t=2160
    * https://youtu.be/0PzR0IoqkkU?t=1453 (por si quieren ver la explicación de **sweep line** también que viene justo antes)
  * (recomendado) https://www.youtube.com/watch?v=CWDQJGaN1gY
  * http://progcomp.cl/fenwicktree
  * https://cs.stackexchange.com/questions/10538/bit-what-is-the-intuition-behind-a-binary-indexed-tree-and-how-was-it-thought-a
  * https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/
* Fenwick Tree 2D:
  * http://www.geeksforgeeks.org/two-dimensional-binary-indexed-tree-or-fenwick-tree/
  * (explicación de Jorge Pérez) https://youtu.be/0PzR0IoqkkU?t=4207
  * https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/#2d
* Wavelet Tree: https://www.dcc.uchile.cl/~jperez/papers/ioiconf16.pdf

### Dynamic Programming (DP):
* ¿Qué es DP?
  * https://www.youtube.com/watch?v=OQ5jsbhAv_M  
  * https://www.youtube.com/watch?v=P8Xa2BitN3I
  * https://www.youtube.com/watch?v=P8Cm_koLdxM
* Bottom-Up vs Top-Down: http://stackoverflow.com/questions/6164629/dynamic-programming-and-memoization-bottom-up-vs-top-down-approaches
* Playlist con muchos ejemplos: https://www.youtube.com/watch?v=8LusJS5-AGo&list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr
* Optimizaciones para DP: 
  * Divide & Conquer Optimization:
    * http://jeffrey-xiao.github.io/#!/blog/posts/2015-12-14-Divide-and-Conquer-Optimization
    * https://www.hackerrank.com/contests/ioi-2014-practice-contest-2/challenges/guardians-lunatics-ioi14/editorial
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Dynamic_Programming/Divide%26ConquerOptimization.cpp     
    * https://www.youtube.com/watch?v=wLXEWuDWnzI
   
### Graphs:
* Slides de Nico Lehmann sobre Grafos:
  * http://campamento2015.progcomp.cl/material (revisar la parte Grafos)
  * http://campamento2016.progcomp.cl/material (revisar la parte Grafos)  
* Play list sobre Grafos: https://www.youtube.com/playlist?list=PLrmLmBdmIlpu2f2g8ltqaaCZiq6GJvl1j
* Breadth First Search (BFS) & Depth First Search (DFS):
  * https://www.youtube.com/watch?v=ImMnYq2zP4Y
  * https://www.youtube.com/watch?v=zaBhtODEL0w
* Flood Fill: https://en.wikipedia.org/wiki/Flood_fill
* Articulation Points (aka Cut Vertices), Bridges (aka Cut Edges) and Biconnected Components (aka Blocks): 
  * Graph Theory: 53. Cut-Vertices: https://www.youtube.com/watch?v=BxAgmaLWaq4
  * Graph Theory: 55. Bridges and Blocks: https://www.youtube.com/watch?v=iGsxKUzW3cs
  * Menger's Theorem: https://www.youtube.com/watch?v=dUAeleBMRCQ
    * https://www.quora.com/How-can-I-prove-without-using-Mengers-theorem-that-any-two-vertices-of-a-2-connected-graph-lie-on-a-common-cycle
  * Articulation Points Graph Algorithm: https://www.youtube.com/watch?v=2kREIkF9UAs
  * http://web.iitd.ac.in/~bspanda/biconnectedMTL776.pdf
  * https://www.hackerearth.com/practice/algorithms/graphs/articulation-points-and-bridges/tutorial/
  * https://www.hackerearth.com/practice/algorithms/graphs/biconnected-components/tutorial/
  * Código de ejemplo: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/articulation-points%2Ccut-edges%2Cbiconnected-components.cpp
* Diameter of a Tree: http://cs.stackexchange.com/questions/22855/algorithm-to-find-diameter-of-a-tree-using-bfs-dfs-why-does-it-work
* Dijkstra:
  * https://www.youtube.com/watch?v=gdmfOwyQlcI
  * https://www-m9.ma.tum.de/graph-algorithms/spp-dijkstra/index_en.html
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/Dijkstra.cpp
* Minimum Spanning Tree:
  * Kruskal's Algorithm:
    * https://www.youtube.com/watch?v=71UQH7Pr9kU
    * https://www.youtube.com/watch?v=fAuF0EuZVCk
  * Prim's Algorithm:
    * https://www.youtube.com/watch?v=cplfcGZmX7I
    * https://www.youtube.com/watch?v=oP2-8ysT3QQ
  * Correcteness Proofs:
    * Proof of Cut Property: https://www.youtube.com/watch?v=P7K7mG8QDVM
    * Proof of Prim's MST algorithm using cut property: https://www.youtube.com/watch?v=UfhUr5QzfiI
    * Correctness of Kruskal's Algorithm: https://www.youtube.com/watch?v=S9PIItOUyzA
  * Example Code: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/MinimumSpanningTree.cpp    
* Topological Sort:
  * https://www.youtube.com/watch?v=ddTC4Zovtbc
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/TopoSort.cpp
* Lowest Common Ancestor (LCA):
  * General Overview of Methods:
    * http://codeforces.com/blog/entry/16221 (skip to the LCA part)
  * Sparse Tables and LCA: https://www.youtube.com/watch?v=EKcQt-74bNw
  * Method 1 (RECOMMENDED): Binary Lifting Method (aka jump pointers: https://en.wikipedia.org/wiki/Level_ancestor_problem#Jump_pointer_algorithm):
    * http://codeforces.com/blog/entry/22325
      * Note: as the post says, this method is very handy as it can be also used to compute querys over paths in Trees
    * https://www.youtube.com/watch?v=kOfa6t8WnbI
  * Method 2: Euler Tour + Range Minimun Query:
    * https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/
    * Sparse Table Algorithm Range Minimum Query: https://www.youtube.com/watch?v=c5O7E_PDO4U
  * Example Code of Both Methods:
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/LCA.cpp
* Level Ancestor:
  * https://en.wikipedia.org/wiki/Level_ancestor_problem
  * https://www.quora.com/Why-does-storing-log-N-pointers-work-in-the-jump-pointer-solution-of-the-level-ancestor-problem
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/LA.cpp
* Heavy-Light Decomposition:
  * https://blog.anudeep2011.com/heavy-light-decomposition/
  * https://www.geeksforgeeks.org/heavy-light-decomposition-set-1-introduction/
  * http://codeforces.com/blog/entry/22072
* Max Flow:
  * Ford-Fulkerson Algorithm:
     * https://www.youtube.com/watch?v=Tl90tNtKvxs
     * https://www.youtube.com/watch?v=XPpmzulEmjA
     * https://www.youtube.com/watch?v=MczX0SM3I84
     * https://www.youtube.com/watch?v=GiN3jRdgxU4
  * Dinic Algorithm (RECOMENDADO):
     * https://www.youtube.com/watch?v=uM06jHdIC70
     * http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15451-f14/www/lectures/lec11/dinic.pdf
     * http://theory.stanford.edu/~tim/w16/l/l2.pdf
     * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/Dinic.cpp
  * Casos de uso:
     * (MUY RECOMENDADO) Ejemplos de problemas usando flujo: https://www.youtube.com/watch?v=nKcVc8XkFSA
     * Maximum Bipartite Matching: http://www.geeksforgeeks.org/maximum-bipartite-matching/

### Strings:
* Trie:
  * https://en.wikipedia.org/wiki/Trie
  * https://www.youtube.com/watch?v=zIjfhVPRZCg
  * https://www.youtube.com/watch?v=AXjmTQ8LEoI
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Strings/Trie.cpp
* KMP (String Pattern Matching):
  * https://www.youtube.com/watch?v=v82y5TCcBhQ
  * https://www.youtube.com/watch?v=GTJr8OvyEVQ
  * https://www.youtube.com/watch?v=KG44VoDtsAA
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Strings/KMP.cpp
* Shortest Repeating Cycle:
  * http://www.geeksforgeeks.org/find-given-string-can-represented-substring-iterating-substring-n-times/
  * http://stackoverflow.com/questions/6021274/finding-shortest-repeating-cycle-in-word
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Strings/shortest_repeating_cycle.cpp

### Mathematics:
* Prime Numbers:
  * Sieve of Eratosthenes (all primes up to N): https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
  * Prime Factorization of Factorials: http://mathforum.org/library/drmath/view/67291.html
* Modular Arithmetics:
  * ¿De qué se trata Modular Arithmetics?
    * Introduction to Modular arithmetic: https://www.youtube.com/watch?v=9lUSKOjV4d0
    * High level introduction to modular arithmetic: https://www.youtube.com/watch?v=r0gYad8auYY
    * Congruence (Modular Arithmetic) & 5 Properties Explained with 7 Problems: Ultimate Shortcuts: https://www.youtube.com/watch?v=B1gD6540uWA
  * Modular Exponentiation By Squaring:
    * https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/binary_modular_exponentiation.cpp
  * Modular Fibonacci with Exponentiation by Squaring:
    * http://mathoverflow.net/questions/40816/fibonacci-series-mod-a-number
  * Euclidean Algorithm:
    * GCD (greatest common divisor): https://www.youtube.com/watch?v=5jLWXwSXJdg
    * GCD extendido: https://www.youtube.com/watch?v=hB34-GSDT3k
    * Multiplicative Inverse Mod N: https://www.youtube.com/watch?v=_bRVA5b4sb4
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/euclidean_algorithm.cpp
  * Modular Binomial Coefficient (Choose(n,k) mod X):
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/modular_binomial_coefficient.cpp

### Geometry:
* Video Repaso de Geometría (SÚPER BUENO):
  * Geometría Computacional [ICPCCL 2016]: https://youtu.be/nk5ejrBWORw?list=PL-c_98SOXhxaXMMfnemh2ihniZsj57L8-
* Códigos varios de geometría 2D: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/Geometry2DUtils.cpp. Incluye:
  * Ejemplo de un struct Point
  * Producto Cruz: Orientación de un punto respecto a un rayo (left, collinear o right)
    * basado en: https://www.geeksforgeeks.org/orientation-3-ordered-points/
  * Ordenar segmentos disjuntos por orden de intersección respecto a un rayo usando producto cruz
  * Detectar intersección de rectángulos
  * Detectar intersección de segmentos
    * basado en: https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/
  * Detectar intersección de círculos
  * Distancia punto - segmento
    * basado en: https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
  * Distancia punto - recta
  * Hashing de ecuación de recta a partir de 2 puntos
* Trigonometría: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/Trigonometry.cpp. Incluye:
  * Cálculo del ángulo de un vector 2D (medido ccw con respecto x+) usando atan2(y,x)
  * Implementación del teorema del coseno para cálcular ángulos internos de triángulos
* Cálculo de Áreas:
  * Teorema de Green (aplicado al caso particular de calcular áreas):
    * lecturas:
        * https://math.stackexchange.com/questions/199003/proving-greens-theorem-for-computing-area
        * https://mathinsight.org/greens_theorem_find_area
    * videos:
        * Green's Theorem: https://www.youtube.com/watch?v=a_zdFvYXX_c
        * 78 - Finding area with Green's theorem: https://www.youtube.com/watch?v=42vEvHpXYP8
        * How to Use Green's Theorem to Find the Area of A Region: https://www.youtube.com/watch?v=w3ugdu0oFgE
        * Green's Theorem: area under an arch | MIT 18.02SC Multivariable Calculus, Fall 2010: https://www.youtube.com/watch?v=KXof0q88xbg
  * Área de un polígono simple:
    * http://math.blogoverflow.com/2014/06/04/greens-theorem-and-area-of-polygons/
    * http://stackoverflow.com/questions/451426/how-do-i-calculate-the-area-of-a-2d-polygon    
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/PolygonArea.cpp
* Sweep Line y Radial Sweep Line:
  * https://en.wikipedia.org/wiki/Sweep_line_algorithm
  * https://www.topcoder.com/community/data-science/data-science-tutorials/line-sweep-algorithms/
  * http://codeforces.com/blog/entry/20377
  * https://apps.topcoder.com/forums/?module=Thread&threadID=684537&start=0&mc=6
* Detectar si un punto está dentro de un polígono:
  * http://geomalgorithms.com/a03-_inclusion.html
  * https://en.wikipedia.org/wiki/Point_in_polygon
  * Código ejemplo: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/PointInPolygon.cpp
  * Point in Convex Polygon: http://stackoverflow.com/questions/1119627/how-to-test-if-a-point-is-inside-of-a-convex-polygon-in-2d-integer-coordinates
* Dualidad Línea Punto:
  * Buenas slides explicando dualidad: https://algo.kaust.edu.sa/Documents/cs372l13.pdf
  * Excelente pdf con demostraciones: https://pdfs.semanticscholar.org/810c/e0c19283481567c6545bf8c0cc8a4dcb8a1f.pdf  
  * Aplicación interactiva: http://students.cec.wustl.edu/~tdeck/duality/
* Convex Hull:
  * Buen video explicando Convex Hull: https://www.youtube.com/watch?v=wRTGDig3jx8
  * Monotone Chain Algorithm (algoritmo recomendado):
    * Video animación: https://www.youtube.com/watch?v=A4uWWnzTplM
    * Ejemplos de implementaciones:
      * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
      * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/ConvexHull.cpp
* Convex Hull Trick:
  * https://wcipeg.com/wiki/Convex_hull_trick
  * https://stackoverflow.com/questions/17834699/what-is-convex-hull-trick-exactly

_______________________________________________

## Instrucciones para participar en contests:

Utilizaremos A2OJ (https://a2oj.com/) como plataforma para realizar contests. A2OJ permite realizar contests  con problemas de diferentes jueces online (Codeforces, Live Archive, UVA, SPOJ, etc.). Por lo tanto, necesitan crearse primero una cuenta en A2OJ, luego deben crearse cuentas en los jueces online que vayamos utilizando, y finalmente deben preocuparse de *linkear* sus cuentas de los jueces con su cuenta de A2OJ (para que A2OJ se pueda dar cuenta de que resolvieron un problema en un juez dado). Los detalles de cómo hacer ese *link* con cada juez salen explicados en su página de account de A2OJ (https://a2oj.com/account).

A priori no sabemos todos los jueces que vamos a utilizar, así que pueden ir creándose las cuentas on demand (para cada contest se publicará con anticipación el link para registrarse + los jueces a utilizar, así que no necesitan crearse todas las cuentas altiro). De todas formas acá abajo están links a posibles jueces (ordenados por probabilidad de uso):

* Codeforces: http://codeforces.com/
* URI: https://www.urionlinejudge.com.br/
* Live Archive: https://icpcarchive.ecs.baylor.edu/
* UVA: https://uva.onlinejudge.org/
* SPOJ: http://www.spoj.com/
* TIMUS: http://acm.timus.ru

## Contests
* Taller 1: https://a2oj.com/contest?ID=35796
  * Disponibilidad: 09/03/2018 - 23/03/2018 (2 semanas)
  * Jueces a utilizar: Codeforces, URI, Live Archive
  * Hints: implementation, math, recursion, backtracking, pruning, DP, HIV (heaviest increasing subsequence), Fenwick Tree
  * Soluciones de ejemplo:
    * Buggy ICPC: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/8189_BuggyICPC.cpp
    * Fundraising: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/Fundraising.cpp
    
* Taller 2: https://a2oj.com/contest?ID=35889
  * Disponibilidad: 16/03/2018 - 06/04/2018 (3 semanas)
  * Jueces a utilizar: Codeforces, URI, Live Archive
  * Hints: brute force, implementation, math, number theory, DP, LIS (longest increasing subsequence), HIV (heaviest increasing subsequence)
  * Soluciones de ejemplo:
    * T-primes: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/230B_T-primes.cpp
    * Daunting Device: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/DauntingDevice.cpp
    * Arranging Heaps: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/ArrangingHeaps.cpp
    
* Taller 3: https://a2oj.com/contest?ID=36030
  * Disponibilidad: 28/03/2018 - 20/04/2018 (3 semanas y fracción)
  * Jueces a utilizar: Codeforces, URI
  * Soluciones de ejemplo:
    * Keep it Energized: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/7213_KeepItEnergized.cpp
    * Fence the Vegetables: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/6826_FenceTheVegetables.cpp
    * Journey Through The Kingdom: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/JourneyThroughTheKingdom.cpp
    * Electrical Pollution: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/ElectricalPollution.cpp
    * Dividing the Names: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/6824_DividingTheNames.cpp
    
* Taller 4: https://a2oj.com/contest?ID=36242
  * Disponibilidad: 13/04/2018 - 27/04/2018 (2 semanas)
  * Jueces a utilizar: Codeforces, URI
  * Soluciones de Ejemplo:
    * HexStatistics: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/HexStatistics.cpp
  
* Taller 5: https://a2oj.com/contest?ID=36321
  * Disponibilidad: 20/04/2018 - 04/05/2018 (2 semanas)
  * Jueces a utilizar: Codeforces, URI, Live Archive
  * Soluciones de ejemplo:
    * Leaders: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/97E_Leaders.cpp
    * HexStatistics: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/HexStatistics.cpp
    
* Taller 6: https://a2oj.com/contest?ID=36417
  * Disponibilidad: 04/05/2018 - 18/05/2018 (2 semanas)
  * Jueces a utilizar: Codeforces, URI, Timus
  * Soluciones de Ejemplo:
    * Join two kingdoms: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/JoinTwoKingdoms.cpp
    * Even Distribution: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/6825_EvenDistribution.cpp
    * Exposing Corruption: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/7207_ExposingCorruption.cpp
    * Painting Fence: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/448C_PaintingFence.cpp
    * New Year Tree: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/379F_NewYearTree.cpp
    * Tree2: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/acm.timus.ru/1752_Tree2.cpp
    * Minimum Spanning Tree for each edge: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/609E_MinimumSpanningTreeForEachEdge.cpp
    * Electrical Pollution: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/ElectricalPollution.cpp
    * Journey Through The Kingdom: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/JourneyThroughTheKingdom.cpp

* Taller 7: https://a2oj.com/contest?ID=36453
  * Disponibilidad: 18/05/2018 - 01/06/2018 (2 semanas)
  * Jueces a utilizar: Codeforces, URI, Live Archive, Timus
  * Soluciones de Ejemplo:
    * Keep it Energized: (háganlo con Dijkstra, la misma idea se aplica a "Journey Through The Kingdom") https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/7213_KeepItEnergized_v2.cpp 
    * Journey Through The Kingdom: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/JourneyThroughTheKingdom.cpp
    * New Year Tree: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/379F_NewYearTree.cpp
    * Tree2: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/acm.timus.ru/1752_Tree2.cpp
    * Necklace: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/4271_Necklace.cpp
    * Leaders: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/97E_Leaders.cpp
    * Even Distribution: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/6825_EvenDistribution.cpp    
    
* Taller 8: https://a2oj.com/contest?ID=36574
  * Disponibilidad: 25/05/2018 - 15/06/2018 (3 semanas)
  * Jueces a utilizar: Codeforces, URI, Live Archive, UVA, SPOJ
  * Soluciones de Ejemplo:
     * Dinosaur Menace: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/DINOSM_DinosaurMenace.cpp
     * Attacking Rooks: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/AttackingRooks.cpp
     * Kill The Werewolf: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/KillTheWerewolf.cpp
     * Keep it Covered: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/8198_KeepItCovered.cpp
  
* Taller 9: https://a2oj.com/contest?ID=36677
  * Disponibilidad: 08/06/2018 - 02/07/2018 (3+ semanas)
  * Jueces a utilizar: Codeforces, URI, Live Archive, SPOJ
  * Soluciones de Ejemplo:
    * Divisors: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/EC_DIVS_Divisors.cpp
    * Xenia and Bit Operations: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/339D_XeniaAndBitOperations.cpp
    * Olympic Games: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Red%20de%20Programaci%C3%B3n%20Competitiva/2016-Competencia-11/J_OlympicGames.cpp
    * The Art of Dealing with ATM: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/524C_TheArtOfDealingWithATMs.cpp
    * Looking for Owls: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/350D_LookingForOwls.cpp
    * Counting Ones: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/CountingOnes.cpp    
    * Counting Self-Rotating Subsets: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/CountingSelfRotatingSubsets_v1.cpp
    * Jupiter Attacks!: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/JupiterAttacks.cpp
    * Vladik And Entertaining Flags: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/811E_VladikAndEntertainingFlags.cpp
    * Last Digit: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/4008_LastDigit.cpp
    * Cvjetici: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/CVJETICI_Cvjetici.cpp
    * Just in Time: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/JustInTime.cpp
    * YAPTCHA: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/4382_YAPTCHA.cpp
    * Arranging Tiles: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/ArrangingTiles.cpp
    * Keep it Covered: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/8198_KeepItCovered.cpp
* Taller Repechaje: https://a2oj.com/contest?ID=36906
  * Disponiblidad: 01/07/2018 - 11/07/2018 (10 días)
  * Jueces a utilizar: Live Archive
__________________________________________________

### Seguimiento de Asistencia y Problemas Resueltos
https://docs.google.com/spreadsheets/d/12meuZQZbcV_yIMSi9UCcieX-eC2tWKEZQkWKtaQSUF0/edit?usp=sharing
